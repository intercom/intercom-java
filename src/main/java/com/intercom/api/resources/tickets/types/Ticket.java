/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.intercom.api.resources.tickets.types;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.JsonValue;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
import com.intercom.api.core.ObjectMappers;
import com.intercom.api.types.FileAttribute;
import com.intercom.api.types.LinkedObjectList;
import com.intercom.api.types.TicketParts;
import java.io.IOException;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import org.jetbrains.annotations.NotNull;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(builder = Ticket.Builder.class)
public final class Ticket {
    private final String id;

    private final String ticketId;

    private final Category category;

    private final Map<String, TicketAttributesValue> ticketAttributes;

    private final TicketState ticketState;

    private final TicketType ticketType;

    private final TicketContacts contacts;

    private final Optional<String> adminAssigneeId;

    private final Optional<String> teamAssigneeId;

    private final Optional<Integer> createdAt;

    private final Optional<Integer> updatedAt;

    private final Optional<Boolean> open;

    private final Optional<Integer> snoozedUntil;

    private final Optional<LinkedObjectList> linkedObjects;

    private final Optional<TicketParts> ticketParts;

    private final Optional<Boolean> isShared;

    private final Optional<String> ticketStateInternalLabel;

    private final Optional<String> ticketStateExternalLabel;

    private final Map<String, Object> additionalProperties;

    private Ticket(
            String id,
            String ticketId,
            Category category,
            Map<String, TicketAttributesValue> ticketAttributes,
            TicketState ticketState,
            TicketType ticketType,
            TicketContacts contacts,
            Optional<String> adminAssigneeId,
            Optional<String> teamAssigneeId,
            Optional<Integer> createdAt,
            Optional<Integer> updatedAt,
            Optional<Boolean> open,
            Optional<Integer> snoozedUntil,
            Optional<LinkedObjectList> linkedObjects,
            Optional<TicketParts> ticketParts,
            Optional<Boolean> isShared,
            Optional<String> ticketStateInternalLabel,
            Optional<String> ticketStateExternalLabel,
            Map<String, Object> additionalProperties) {
        this.id = id;
        this.ticketId = ticketId;
        this.category = category;
        this.ticketAttributes = ticketAttributes;
        this.ticketState = ticketState;
        this.ticketType = ticketType;
        this.contacts = contacts;
        this.adminAssigneeId = adminAssigneeId;
        this.teamAssigneeId = teamAssigneeId;
        this.createdAt = createdAt;
        this.updatedAt = updatedAt;
        this.open = open;
        this.snoozedUntil = snoozedUntil;
        this.linkedObjects = linkedObjects;
        this.ticketParts = ticketParts;
        this.isShared = isShared;
        this.ticketStateInternalLabel = ticketStateInternalLabel;
        this.ticketStateExternalLabel = ticketStateExternalLabel;
        this.additionalProperties = additionalProperties;
    }

    /**
     * @return Always ticket
     */
    @JsonProperty("type")
    public String getType() {
        return "ticket";
    }

    /**
     * @return The unique identifier for the ticket which is given by Intercom.
     */
    @JsonProperty("id")
    public String getId() {
        return id;
    }

    /**
     * @return The ID of the Ticket used in the Intercom Inbox and Messenger. Do not use ticket_id for API queries.
     */
    @JsonProperty("ticket_id")
    public String getTicketId() {
        return ticketId;
    }

    /**
     * @return Category of the Ticket.
     */
    @JsonProperty("category")
    public Category getCategory() {
        return category;
    }

    @JsonProperty("ticket_attributes")
    public Map<String, TicketAttributesValue> getTicketAttributes() {
        return ticketAttributes;
    }

    /**
     * @return The state the ticket is currently in
     */
    @JsonProperty("ticket_state")
    public TicketState getTicketState() {
        return ticketState;
    }

    @JsonProperty("ticket_type")
    public TicketType getTicketType() {
        return ticketType;
    }

    @JsonProperty("contacts")
    public TicketContacts getContacts() {
        return contacts;
    }

    /**
     * @return The id representing the admin assigned to the ticket.
     */
    @JsonProperty("admin_assignee_id")
    public Optional<String> getAdminAssigneeId() {
        return adminAssigneeId;
    }

    /**
     * @return The id representing the team assigned to the ticket.
     */
    @JsonProperty("team_assignee_id")
    public Optional<String> getTeamAssigneeId() {
        return teamAssigneeId;
    }

    /**
     * @return The time the ticket was created as a UTC Unix timestamp.
     */
    @JsonProperty("created_at")
    public Optional<Integer> getCreatedAt() {
        return createdAt;
    }

    /**
     * @return The last time the ticket was updated as a UTC Unix timestamp.
     */
    @JsonProperty("updated_at")
    public Optional<Integer> getUpdatedAt() {
        return updatedAt;
    }

    /**
     * @return Whether or not the ticket is open. If false, the ticket is closed.
     */
    @JsonProperty("open")
    public Optional<Boolean> getOpen() {
        return open;
    }

    /**
     * @return The time the ticket will be snoozed until as a UTC Unix timestamp. If null, the ticket is not currently snoozed.
     */
    @JsonProperty("snoozed_until")
    public Optional<Integer> getSnoozedUntil() {
        return snoozedUntil;
    }

    @JsonProperty("linked_objects")
    public Optional<LinkedObjectList> getLinkedObjects() {
        return linkedObjects;
    }

    @JsonProperty("ticket_parts")
    public Optional<TicketParts> getTicketParts() {
        return ticketParts;
    }

    /**
     * @return Whether or not the ticket is shared with the customer.
     */
    @JsonProperty("is_shared")
    public Optional<Boolean> getIsShared() {
        return isShared;
    }

    /**
     * @return The state the ticket is currently in, in a human readable form - visible in Intercom
     */
    @JsonProperty("ticket_state_internal_label")
    public Optional<String> getTicketStateInternalLabel() {
        return ticketStateInternalLabel;
    }

    /**
     * @return The state the ticket is currently in, in a human readable form - visible to customers, in the messenger, email and tickets portal.
     */
    @JsonProperty("ticket_state_external_label")
    public Optional<String> getTicketStateExternalLabel() {
        return ticketStateExternalLabel;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof Ticket && equalTo((Ticket) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(Ticket other) {
        return id.equals(other.id)
                && ticketId.equals(other.ticketId)
                && category.equals(other.category)
                && ticketAttributes.equals(other.ticketAttributes)
                && ticketState.equals(other.ticketState)
                && ticketType.equals(other.ticketType)
                && contacts.equals(other.contacts)
                && adminAssigneeId.equals(other.adminAssigneeId)
                && teamAssigneeId.equals(other.teamAssigneeId)
                && createdAt.equals(other.createdAt)
                && updatedAt.equals(other.updatedAt)
                && open.equals(other.open)
                && snoozedUntil.equals(other.snoozedUntil)
                && linkedObjects.equals(other.linkedObjects)
                && ticketParts.equals(other.ticketParts)
                && isShared.equals(other.isShared)
                && ticketStateInternalLabel.equals(other.ticketStateInternalLabel)
                && ticketStateExternalLabel.equals(other.ticketStateExternalLabel);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(
                this.id,
                this.ticketId,
                this.category,
                this.ticketAttributes,
                this.ticketState,
                this.ticketType,
                this.contacts,
                this.adminAssigneeId,
                this.teamAssigneeId,
                this.createdAt,
                this.updatedAt,
                this.open,
                this.snoozedUntil,
                this.linkedObjects,
                this.ticketParts,
                this.isShared,
                this.ticketStateInternalLabel,
                this.ticketStateExternalLabel);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static IdStage builder() {
        return new Builder();
    }

    public interface IdStage {
        TicketIdStage id(@NotNull String id);

        Builder from(Ticket other);
    }

    public interface TicketIdStage {
        CategoryStage ticketId(@NotNull String ticketId);
    }

    public interface CategoryStage {
        TicketStateStage category(@NotNull Category category);
    }

    public interface TicketStateStage {
        TicketTypeStage ticketState(@NotNull TicketState ticketState);
    }

    public interface TicketTypeStage {
        ContactsStage ticketType(@NotNull TicketType ticketType);
    }

    public interface ContactsStage {
        _FinalStage contacts(@NotNull TicketContacts contacts);
    }

    public interface _FinalStage {
        Ticket build();

        _FinalStage ticketAttributes(Map<String, TicketAttributesValue> ticketAttributes);

        _FinalStage putAllTicketAttributes(Map<String, TicketAttributesValue> ticketAttributes);

        _FinalStage ticketAttributes(String key, TicketAttributesValue value);

        _FinalStage adminAssigneeId(Optional<String> adminAssigneeId);

        _FinalStage adminAssigneeId(String adminAssigneeId);

        _FinalStage teamAssigneeId(Optional<String> teamAssigneeId);

        _FinalStage teamAssigneeId(String teamAssigneeId);

        _FinalStage createdAt(Optional<Integer> createdAt);

        _FinalStage createdAt(Integer createdAt);

        _FinalStage updatedAt(Optional<Integer> updatedAt);

        _FinalStage updatedAt(Integer updatedAt);

        _FinalStage open(Optional<Boolean> open);

        _FinalStage open(Boolean open);

        _FinalStage snoozedUntil(Optional<Integer> snoozedUntil);

        _FinalStage snoozedUntil(Integer snoozedUntil);

        _FinalStage linkedObjects(Optional<LinkedObjectList> linkedObjects);

        _FinalStage linkedObjects(LinkedObjectList linkedObjects);

        _FinalStage ticketParts(Optional<TicketParts> ticketParts);

        _FinalStage ticketParts(TicketParts ticketParts);

        _FinalStage isShared(Optional<Boolean> isShared);

        _FinalStage isShared(Boolean isShared);

        _FinalStage ticketStateInternalLabel(Optional<String> ticketStateInternalLabel);

        _FinalStage ticketStateInternalLabel(String ticketStateInternalLabel);

        _FinalStage ticketStateExternalLabel(Optional<String> ticketStateExternalLabel);

        _FinalStage ticketStateExternalLabel(String ticketStateExternalLabel);
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder
            implements IdStage,
                    TicketIdStage,
                    CategoryStage,
                    TicketStateStage,
                    TicketTypeStage,
                    ContactsStage,
                    _FinalStage {
        private String id;

        private String ticketId;

        private Category category;

        private TicketState ticketState;

        private TicketType ticketType;

        private TicketContacts contacts;

        private Optional<String> ticketStateExternalLabel = Optional.empty();

        private Optional<String> ticketStateInternalLabel = Optional.empty();

        private Optional<Boolean> isShared = Optional.empty();

        private Optional<TicketParts> ticketParts = Optional.empty();

        private Optional<LinkedObjectList> linkedObjects = Optional.empty();

        private Optional<Integer> snoozedUntil = Optional.empty();

        private Optional<Boolean> open = Optional.empty();

        private Optional<Integer> updatedAt = Optional.empty();

        private Optional<Integer> createdAt = Optional.empty();

        private Optional<String> teamAssigneeId = Optional.empty();

        private Optional<String> adminAssigneeId = Optional.empty();

        private Map<String, TicketAttributesValue> ticketAttributes = new LinkedHashMap<>();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        @java.lang.Override
        public Builder from(Ticket other) {
            id(other.getId());
            ticketId(other.getTicketId());
            category(other.getCategory());
            ticketAttributes(other.getTicketAttributes());
            ticketState(other.getTicketState());
            ticketType(other.getTicketType());
            contacts(other.getContacts());
            adminAssigneeId(other.getAdminAssigneeId());
            teamAssigneeId(other.getTeamAssigneeId());
            createdAt(other.getCreatedAt());
            updatedAt(other.getUpdatedAt());
            open(other.getOpen());
            snoozedUntil(other.getSnoozedUntil());
            linkedObjects(other.getLinkedObjects());
            ticketParts(other.getTicketParts());
            isShared(other.getIsShared());
            ticketStateInternalLabel(other.getTicketStateInternalLabel());
            ticketStateExternalLabel(other.getTicketStateExternalLabel());
            return this;
        }

        /**
         * <p>The unique identifier for the ticket which is given by Intercom.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        @JsonSetter("id")
        public TicketIdStage id(@NotNull String id) {
            this.id = Objects.requireNonNull(id, "id must not be null");
            return this;
        }

        /**
         * <p>The ID of the Ticket used in the Intercom Inbox and Messenger. Do not use ticket_id for API queries.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        @JsonSetter("ticket_id")
        public CategoryStage ticketId(@NotNull String ticketId) {
            this.ticketId = Objects.requireNonNull(ticketId, "ticketId must not be null");
            return this;
        }

        /**
         * <p>Category of the Ticket.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        @JsonSetter("category")
        public TicketStateStage category(@NotNull Category category) {
            this.category = Objects.requireNonNull(category, "category must not be null");
            return this;
        }

        /**
         * <p>The state the ticket is currently in</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        @JsonSetter("ticket_state")
        public TicketTypeStage ticketState(@NotNull TicketState ticketState) {
            this.ticketState = Objects.requireNonNull(ticketState, "ticketState must not be null");
            return this;
        }

        @java.lang.Override
        @JsonSetter("ticket_type")
        public ContactsStage ticketType(@NotNull TicketType ticketType) {
            this.ticketType = Objects.requireNonNull(ticketType, "ticketType must not be null");
            return this;
        }

        @java.lang.Override
        @JsonSetter("contacts")
        public _FinalStage contacts(@NotNull TicketContacts contacts) {
            this.contacts = Objects.requireNonNull(contacts, "contacts must not be null");
            return this;
        }

        /**
         * <p>The state the ticket is currently in, in a human readable form - visible to customers, in the messenger, email and tickets portal.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage ticketStateExternalLabel(String ticketStateExternalLabel) {
            this.ticketStateExternalLabel = Optional.ofNullable(ticketStateExternalLabel);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "ticket_state_external_label", nulls = Nulls.SKIP)
        public _FinalStage ticketStateExternalLabel(Optional<String> ticketStateExternalLabel) {
            this.ticketStateExternalLabel = ticketStateExternalLabel;
            return this;
        }

        /**
         * <p>The state the ticket is currently in, in a human readable form - visible in Intercom</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage ticketStateInternalLabel(String ticketStateInternalLabel) {
            this.ticketStateInternalLabel = Optional.ofNullable(ticketStateInternalLabel);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "ticket_state_internal_label", nulls = Nulls.SKIP)
        public _FinalStage ticketStateInternalLabel(Optional<String> ticketStateInternalLabel) {
            this.ticketStateInternalLabel = ticketStateInternalLabel;
            return this;
        }

        /**
         * <p>Whether or not the ticket is shared with the customer.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage isShared(Boolean isShared) {
            this.isShared = Optional.ofNullable(isShared);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "is_shared", nulls = Nulls.SKIP)
        public _FinalStage isShared(Optional<Boolean> isShared) {
            this.isShared = isShared;
            return this;
        }

        @java.lang.Override
        public _FinalStage ticketParts(TicketParts ticketParts) {
            this.ticketParts = Optional.ofNullable(ticketParts);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "ticket_parts", nulls = Nulls.SKIP)
        public _FinalStage ticketParts(Optional<TicketParts> ticketParts) {
            this.ticketParts = ticketParts;
            return this;
        }

        @java.lang.Override
        public _FinalStage linkedObjects(LinkedObjectList linkedObjects) {
            this.linkedObjects = Optional.ofNullable(linkedObjects);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "linked_objects", nulls = Nulls.SKIP)
        public _FinalStage linkedObjects(Optional<LinkedObjectList> linkedObjects) {
            this.linkedObjects = linkedObjects;
            return this;
        }

        /**
         * <p>The time the ticket will be snoozed until as a UTC Unix timestamp. If null, the ticket is not currently snoozed.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage snoozedUntil(Integer snoozedUntil) {
            this.snoozedUntil = Optional.ofNullable(snoozedUntil);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "snoozed_until", nulls = Nulls.SKIP)
        public _FinalStage snoozedUntil(Optional<Integer> snoozedUntil) {
            this.snoozedUntil = snoozedUntil;
            return this;
        }

        /**
         * <p>Whether or not the ticket is open. If false, the ticket is closed.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage open(Boolean open) {
            this.open = Optional.ofNullable(open);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "open", nulls = Nulls.SKIP)
        public _FinalStage open(Optional<Boolean> open) {
            this.open = open;
            return this;
        }

        /**
         * <p>The last time the ticket was updated as a UTC Unix timestamp.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage updatedAt(Integer updatedAt) {
            this.updatedAt = Optional.ofNullable(updatedAt);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "updated_at", nulls = Nulls.SKIP)
        public _FinalStage updatedAt(Optional<Integer> updatedAt) {
            this.updatedAt = updatedAt;
            return this;
        }

        /**
         * <p>The time the ticket was created as a UTC Unix timestamp.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage createdAt(Integer createdAt) {
            this.createdAt = Optional.ofNullable(createdAt);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "created_at", nulls = Nulls.SKIP)
        public _FinalStage createdAt(Optional<Integer> createdAt) {
            this.createdAt = createdAt;
            return this;
        }

        /**
         * <p>The id representing the team assigned to the ticket.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage teamAssigneeId(String teamAssigneeId) {
            this.teamAssigneeId = Optional.ofNullable(teamAssigneeId);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "team_assignee_id", nulls = Nulls.SKIP)
        public _FinalStage teamAssigneeId(Optional<String> teamAssigneeId) {
            this.teamAssigneeId = teamAssigneeId;
            return this;
        }

        /**
         * <p>The id representing the admin assigned to the ticket.</p>
         * @return Reference to {@code this} so that method calls can be chained together.
         */
        @java.lang.Override
        public _FinalStage adminAssigneeId(String adminAssigneeId) {
            this.adminAssigneeId = Optional.ofNullable(adminAssigneeId);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "admin_assignee_id", nulls = Nulls.SKIP)
        public _FinalStage adminAssigneeId(Optional<String> adminAssigneeId) {
            this.adminAssigneeId = adminAssigneeId;
            return this;
        }

        @java.lang.Override
        public _FinalStage ticketAttributes(String key, TicketAttributesValue value) {
            this.ticketAttributes.put(key, value);
            return this;
        }

        @java.lang.Override
        public _FinalStage putAllTicketAttributes(Map<String, TicketAttributesValue> ticketAttributes) {
            this.ticketAttributes.putAll(ticketAttributes);
            return this;
        }

        @java.lang.Override
        @JsonSetter(value = "ticket_attributes", nulls = Nulls.SKIP)
        public _FinalStage ticketAttributes(Map<String, TicketAttributesValue> ticketAttributes) {
            this.ticketAttributes.clear();
            this.ticketAttributes.putAll(ticketAttributes);
            return this;
        }

        @java.lang.Override
        public Ticket build() {
            return new Ticket(
                    id,
                    ticketId,
                    category,
                    ticketAttributes,
                    ticketState,
                    ticketType,
                    contacts,
                    adminAssigneeId,
                    teamAssigneeId,
                    createdAt,
                    updatedAt,
                    open,
                    snoozedUntil,
                    linkedObjects,
                    ticketParts,
                    isShared,
                    ticketStateInternalLabel,
                    ticketStateExternalLabel,
                    additionalProperties);
        }
    }

    public enum TicketState {
        SUBMITTED("submitted"),

        IN_PROGRESS("in_progress"),

        WAITING_ON_CUSTOMER("waiting_on_customer"),

        RESOLVED("resolved");

        private final String value;

        TicketState(String value) {
            this.value = value;
        }

        @JsonValue
        @java.lang.Override
        public String toString() {
            return this.value;
        }
    }

    public enum Category {
        CUSTOMER("Customer"),

        BACK_OFFICE("Back-office"),

        TRACKER("Tracker");

        private final String value;

        Category(String value) {
            this.value = value;
        }

        @JsonValue
        @java.lang.Override
        public String toString() {
            return this.value;
        }
    }

    @JsonDeserialize(using = TicketAttributesValue.Deserializer.class)
    public static final class TicketAttributesValue {
        private final Object value;

        private final int type;

        private TicketAttributesValue(Object value, int type) {
            this.value = value;
            this.type = type;
        }

        @JsonValue
        public Object get() {
            return this.value;
        }

        public <T> T visit(Visitor<T> visitor) {
            if (this.type == 0) {
                return visitor.visit((Optional<String>) this.value);
            } else if (this.type == 1) {
                return visitor.visit((double) this.value);
            } else if (this.type == 2) {
                return visitor.visit((boolean) this.value);
            } else if (this.type == 3) {
                return visitor.visit((List<Object>) this.value);
            } else if (this.type == 4) {
                return visitor.visit((FileAttribute) this.value);
            }
            throw new IllegalStateException("Failed to visit value. This should never happen.");
        }

        @java.lang.Override
        public boolean equals(Object other) {
            if (this == other) return true;
            return other instanceof TicketAttributesValue && equalTo((TicketAttributesValue) other);
        }

        private boolean equalTo(TicketAttributesValue other) {
            return value.equals(other.value);
        }

        @java.lang.Override
        public int hashCode() {
            return Objects.hash(this.value);
        }

        @java.lang.Override
        public String toString() {
            return this.value.toString();
        }

        public static TicketAttributesValue of(Optional<String> value) {
            return new TicketAttributesValue(value, 0);
        }

        public static TicketAttributesValue of(double value) {
            return new TicketAttributesValue(value, 1);
        }

        public static TicketAttributesValue of(boolean value) {
            return new TicketAttributesValue(value, 2);
        }

        public static TicketAttributesValue of(List<Object> value) {
            return new TicketAttributesValue(value, 3);
        }

        public static TicketAttributesValue of(FileAttribute value) {
            return new TicketAttributesValue(value, 4);
        }

        public interface Visitor<T> {
            T visit(Optional<String> value);

            T visit(double value);

            T visit(boolean value);

            T visit(List<Object> value);

            T visit(FileAttribute value);
        }

        static final class Deserializer extends StdDeserializer<TicketAttributesValue> {
            Deserializer() {
                super(TicketAttributesValue.class);
            }

            @java.lang.Override
            public TicketAttributesValue deserialize(JsonParser p, DeserializationContext context) throws IOException {
                Object value = p.readValueAs(Object.class);
                try {
                    return of(ObjectMappers.JSON_MAPPER.convertValue(value, new TypeReference<Optional<String>>() {}));
                } catch (IllegalArgumentException e) {
                }
                if (value instanceof Double) {
                    return of((Double) value);
                }
                if (value instanceof Boolean) {
                    return of((Boolean) value);
                }
                try {
                    return of(ObjectMappers.JSON_MAPPER.convertValue(value, new TypeReference<List<Object>>() {}));
                } catch (IllegalArgumentException e) {
                }
                try {
                    return of(ObjectMappers.JSON_MAPPER.convertValue(value, FileAttribute.class));
                } catch (IllegalArgumentException e) {
                }
                throw new JsonParseException(p, "Failed to deserialize");
            }
        }
    }
}
